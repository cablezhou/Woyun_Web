<script setup>
import { ref, reactive, onMounted, nextTick, computed, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuth } from '../stores/auth.js'
import { 
  getCurrentUserInfo, 
  getUserInfo, 
  updateUserInfo, 
  uploadAvatar, 
  getUserPhotos, 
  uploadPhotos, 
  deletePhoto as deletePhotoAPI,
  getUserPosts
} from '../api/user.js'
import { getUserRoutes, updateRoute, deleteRoute as deleteRouteAPI } from '../api/routes.js'
import { ElMessage, ElLoading, ElMessageBox } from 'element-plus'

const route = useRoute()
const router = useRouter()
const { currentUser, updateUserInfo: updateAuthUserInfo } = useAuth()
const activeMenu = ref('4') // ä¸ªäººä¸»é¡µåº”è¯¥å¯¹åº”"æ´»åŠ¨åŠ¨æ€"èœå•é¡¹

// ç›‘å¬currentUserå˜åŒ–ï¼Œç¡®ä¿å¯¼èˆªæ­£ç¡®
watch(
  () => currentUser.value,
  (newUser) => {
    if (!newUser && route.name === 'userProfile') {
      // å¦‚æœç”¨æˆ·æœªç™»å½•ä½†è¯•å›¾è®¿é—®ä¸ªäººä¸»é¡µï¼Œé‡å®šå‘åˆ°ç¤¾åŒº
      router.push('/community').catch(err => {
        console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
      })
    }
  },
  { immediate: true }
)

// çŠ¶æ€ç®¡ç†
const showImageViewer = ref(false)
const currentViewImage = ref('')
const viewerImages = ref([])
const currentImageIndex = ref(0)
const editingName = ref(false)
const editingTitle = ref(false)
const editNameValue = ref('')
const editTitleValue = ref('')
const isLoading = ref(true)
const isUploading = ref(false)
const isCurrentUser = computed(() => {
  const routeUserId = parseInt(route.params.id)
  return routeUserId === currentUser.value?.id
})

// è·¯çº¿ç¼–è¾‘ç›¸å…³
const showRouteEditDialog = ref(false)
const isRouteEditing = ref(false)
const currentEditingRouteId = ref(null)
const routeEditFormRef = ref(null)

const routeEditForm = reactive({
  title: '',
  description: '',
  difficulty: '',
  routeType: ''
})

const routeEditFormRules = {
  title: [
    { required: true, message: 'è¯·è¾“å…¥è·¯çº¿æ ‡é¢˜', trigger: 'blur' }
  ],
  description: [
    { required: true, message: 'è¯·è¾“å…¥è·¯çº¿æè¿°', trigger: 'blur' }
  ],
  difficulty: [
    { required: true, message: 'è¯·é€‰æ‹©éš¾åº¦ç­‰çº§', trigger: 'change' }
  ],
  routeType: [
    { required: true, message: 'è¯·é€‰æ‹©è·¯çº¿ç±»å‹', trigger: 'change' }
  ]
}

// è®¡ç®—å±æ€§ï¼šå¤„ç†å¤´åƒ URL
const computedAvatarUrl = computed(() => {
  const avatarUrl = userProfile.value.avatarUrl
  if (!avatarUrl) {
    return '/imagines/members/avatar/member1.jpg'
  }
  
  // å¦‚æœå·²ç»æ˜¯å®Œæ•´URLï¼Œç›´æ¥è¿”å›
  if (avatarUrl.startsWith('http')) {
    return avatarUrl
  }
  
  // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ·»åŠ base URL
  if (avatarUrl.startsWith('/')) {
    return `http://localhost:8080${avatarUrl}`
  }
  
  // å…¶ä»–æƒ…å†µä¹ŸåŠ ä¸ŠåŸºç¡€URL
  return `http://localhost:8080/${avatarUrl}`
})

// è®¡ç®—å±æ€§ï¼šå¤„ç†ç›¸å†Œç…§ç‰‡ URL
const computedPhotos = computed(() => {
  return userProfile.value.photos.map(photo => {
    const photoUrl = photo.photoUrl || photo.url
    if (!photoUrl) return photo
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å®Œæ•´URL
    if (photoUrl.startsWith('http')) {
      return {
        ...photo,
        photoUrl: photoUrl,
        url: photoUrl
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸å¯¹è·¯å¾„
    if (photoUrl.startsWith('/')) {
      const fullUrl = `http://localhost:8080${photoUrl}`
      return {
        ...photo,
        photoUrl: fullUrl,
        url: fullUrl
      }
    }
    
    // å…¶ä»–æƒ…å†µä¹ŸåŠ ä¸ŠåŸºç¡€URL
    const fullUrl = `http://localhost:8080/${photoUrl}`
    return {
      ...photo,
      photoUrl: fullUrl,
      url: fullUrl
    }
  })
})

// DOMå¼•ç”¨
const backgroundRef = ref(null)
const userInfoRef = ref(null)
const galleryRef = ref(null)
const postsRef = ref(null)
const routesRef = ref(null)  // æ·»åŠ è·¯çº¿åŒºåŸŸå¼•ç”¨
const postRefs = reactive({})
const avatarInput = ref(null)
const photosInput = ref(null)
const nameInput = ref(null)
const titleInput = ref(null)

// ç”¨æˆ·èµ„æ–™æ•°æ®
const userProfile = ref({
  id: null,
  name: '',
  title: '',
  bio: '',
  avatar: '',
  joinDate: '',
  stats: {
    postsCount: 0,
    totalLikesReceived: 0,
    daysAsMember: 0
  },
  photos: [],
  photoAlbumPreview: []
})

// ç”¨æˆ·åŠ¨æ€æ•°æ®
const userPosts = ref([])

// ç”¨æˆ·è·¯çº¿æ•°æ®
const userRoutes = ref([])

// åŠ è½½ç”¨æˆ·ä¿¡æ¯
const loadUserProfile = async () => {
  try {
    isLoading.value = true
    const userId = parseInt(route.params.id)
    
    let userInfo
    if (isCurrentUser.value) {
      // è·å–å½“å‰ç”¨æˆ·çš„å®Œæ•´ä¿¡æ¯
      userInfo = await getCurrentUserInfo()
    } else {
      // è·å–æŒ‡å®šç”¨æˆ·çš„å…¬å¼€ä¿¡æ¯
      userInfo = await getUserInfo(userId)
    }
    
    userProfile.value = {
      ...userInfo,
      stats: {
        postsCount: userInfo.postCount || 0,
        totalLikesReceived: userInfo.totalLikesReceived || 0,
        daysAsMember: userInfo.daysAsMember || 0
      },
      photos: userInfo.photoAlbumPreview || []
    }
    
    console.log('ç”¨æˆ·ä¿¡æ¯åŠ è½½æˆåŠŸ:', userProfile.value)
    
  } catch (error) {
    console.error('åŠ è½½ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error)
    ElMessage.error('åŠ è½½ç”¨æˆ·ä¿¡æ¯å¤±è´¥')
  } finally {
    isLoading.value = false
  }
}

// åŠ è½½ç”¨æˆ·è·¯çº¿
const loadUserRoutes = async () => {
  try {
    // ç¡®ä¿æœ‰ç”¨æˆ·ID
    const userId = parseInt(route.params.id)
    if (!userId) {
      console.warn('æ— æ³•åŠ è½½ç”¨æˆ·è·¯çº¿ï¼šæ— æ•ˆçš„ç”¨æˆ·ID')
      return
    }
    
    console.log('ğŸ” åŠ è½½ç”¨æˆ·è·¯çº¿ï¼Œç”¨æˆ·ID:', userId)
    const routesData = await getUserRoutes(userId, { page: 0, size: 10 })
    console.log('ğŸ“¨ ç”¨æˆ·è·¯çº¿å“åº”:', routesData)
    
    // å¤„ç†è·¯çº¿æ•°æ®
    // æ ¹æ®APIæ–‡æ¡£ï¼Œå“åº”æ ¼å¼ä¸º {code: 200, message: "æ“ä½œæˆåŠŸ", data: {...}}
    // æˆ‘ä»¬éœ€è¦æå–dataå­—æ®µï¼Œç„¶åå†å¤„ç†content
    const responseData = routesData.data || routesData
    let rawRoutes = responseData.content || responseData || []
    console.log('ğŸ“‹ æå–çš„è·¯çº¿åˆ—è¡¨:', rawRoutes)
    
    // å¤„ç†è·¯çº¿æ•°æ®æ ¼å¼ - ä½¿ç”¨åç«¯ç”Ÿæˆçš„ç¼©ç•¥å›¾
    const processedRoutes = rawRoutes.map(route => {
      // å¤„ç†ç¼©ç•¥å›¾URLï¼Œä¼˜å…ˆä½¿ç”¨thumbnailUrlï¼ˆåç«¯ç”Ÿæˆçš„ç¼©ç•¥å›¾ï¼‰
      let thumbnail = '/imagines/Background2.jpg'
      if (route.thumbnailUrl) {
        // ä½¿ç”¨åç«¯ç”Ÿæˆçš„ç¼©ç•¥å›¾
        thumbnail = route.thumbnailUrl.startsWith('http') ? route.thumbnailUrl : `http://localhost:8080${route.thumbnailUrl}`
      } else if (route.thumbnail) {
        // å…¼å®¹æ—§çš„thumbnailå­—æ®µ
        thumbnail = route.thumbnail.startsWith('http') ? route.thumbnail : `http://localhost:8080${route.thumbnail}`
      }
      
      console.log('ğŸ–¼ï¸ è·¯çº¿ç¼©ç•¥å›¾URL:', thumbnail)
      
      return {
        id: route.id,
        title: route.title,
        description: route.description,
        distance: route.distance,
        elevation: route.elevationGain || route.elevation || 0,
        estimatedTime: route.estimatedTime || 'æœªçŸ¥',
        difficulty: route.difficulty || 'medium',
        type: route.routeType || route.type || 'scenic', // æ³¨æ„æ˜¯routeTypeè€Œä¸æ˜¯type
        thumbnail: thumbnail,
        createdAt: new Date(route.createdAt)
      }
    })
    
    userRoutes.value = processedRoutes
    
    console.log('âœ… ç”¨æˆ·è·¯çº¿åŠ è½½æˆåŠŸ:', processedRoutes.length, 'æ¡')
    
  } catch (error) {
    console.error('âŒ åŠ è½½ç”¨æˆ·è·¯çº¿å¤±è´¥:', error)
    // ä¸æ˜¾ç¤ºé”™è¯¯ï¼Œå› ä¸ºè·¯çº¿åŠŸèƒ½å¯èƒ½è¿˜æœªå®Œå…¨å®ç°
  }
}

// åˆ·æ–°ç”¨æˆ·è·¯çº¿
const refreshRoutes = async () => {
  await loadUserRoutes()
  ElMessage.success('è·¯çº¿åˆ—è¡¨å·²åˆ·æ–°')
}

// ç¼–è¾‘è·¯çº¿
const editRoute = (route) => {
  // è®¾ç½®å½“å‰ç¼–è¾‘çš„è·¯çº¿ID
  currentEditingRouteId.value = route.id
  
  // å¡«å……è¡¨å•æ•°æ®
  routeEditForm.title = route.title
  routeEditForm.description = route.description
  routeEditForm.difficulty = route.difficulty
  routeEditForm.routeType = route.type
  
  // æ˜¾ç¤ºç¼–è¾‘å¯¹è¯æ¡†
  showRouteEditDialog.value = true
}

// æäº¤è·¯çº¿ç¼–è¾‘
const submitRouteEdit = async () => {
  if (!routeEditFormRef.value) return
  
  await routeEditFormRef.value.validate(async (valid) => {
    if (!valid) {
      ElMessage.error('è¯·å¡«å†™æ‰€æœ‰å¿…å¡«é¡¹')
      return
    }
    
    try {
      isRouteEditing.value = true
      
      // å‡†å¤‡æ›´æ–°æ•°æ®
      const updateData = {
        title: routeEditForm.title,
        description: routeEditForm.description,
        difficulty: routeEditForm.difficulty,
        routeType: routeEditForm.routeType
      }
      
      // è°ƒç”¨APIæ›´æ–°è·¯çº¿
      const updatedRoute = await updateRoute(currentEditingRouteId.value, updateData)
      
      // æ›´æ–°æœ¬åœ°æ•°æ®
      const routeIndex = userRoutes.value.findIndex(r => r.id === currentEditingRouteId.value)
      if (routeIndex !== -1) {
        userRoutes.value[routeIndex] = {
          ...userRoutes.value[routeIndex],
          title: updatedRoute.title,
          description: updatedRoute.description,
          difficulty: updatedRoute.difficulty,
          type: updatedRoute.routeType || updatedRoute.type
        }
      }
      
      // å…³é—­å¯¹è¯æ¡†
      showRouteEditDialog.value = false
      
      ElMessage.success('è·¯çº¿æ›´æ–°æˆåŠŸ')
      
    } catch (error) {
      console.error('æ›´æ–°è·¯çº¿å¤±è´¥:', error)
      ElMessage.error('æ›´æ–°è·¯çº¿å¤±è´¥: ' + (error.message || 'æœªçŸ¥é”™è¯¯'))
    } finally {
      isRouteEditing.value = false
    }
  })
}

// åˆ é™¤è·¯çº¿
const deleteRouteConfirm = async (routeId) => {
  try {
    await ElMessageBox.confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è·¯çº¿å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚', 'æç¤º', {
      confirmButtonText: 'ç¡®å®š',
      cancelButtonText: 'å–æ¶ˆ',
      type: 'warning'
    })
    
    // è°ƒç”¨APIåˆ é™¤è·¯çº¿
    await deleteRouteAPI(routeId)
    
    // ä»æœ¬åœ°æ•°æ®ä¸­ç§»é™¤
    const routeIndex = userRoutes.value.findIndex(r => r.id === routeId)
    if (routeIndex !== -1) {
      userRoutes.value.splice(routeIndex, 1)
    }
    
    ElMessage.success('è·¯çº¿åˆ é™¤æˆåŠŸ')
    
  } catch (error) {
    if (error !== 'cancel') {
      console.error('åˆ é™¤è·¯çº¿å¤±è´¥:', error)
      ElMessage.error('åˆ é™¤è·¯çº¿å¤±è´¥: ' + (error.message || 'æœªçŸ¥é”™è¯¯'))
    }
  }
}

// åŠ è½½ç”¨æˆ·åŠ¨æ€
const loadUserPosts = async () => {
  try {
    const userId = parseInt(route.params.id)
    console.log('ğŸ” åŠ è½½ç”¨æˆ·åŠ¨æ€ï¼Œç”¨æˆ·ID:', userId)
    
    const postsData = await getUserPosts(userId, { page: 0, size: 20 })
    console.log('ğŸ“¨ åŸå§‹åŠ¨æ€æ•°æ®:', postsData)
    
    // å¤„ç†åˆ†é¡µæ•°æ®å’Œæ•°æ®æ ¼å¼
    // æ ¹æ®APIæ–‡æ¡£ï¼Œå“åº”æ ¼å¼ä¸º {code: 200, message: "æ“ä½œæˆåŠŸ", data: {...}}
    // æˆ‘ä»¬éœ€è¦æå–dataå­—æ®µï¼Œç„¶åå†å¤„ç†content
    const responseData = postsData.data || postsData
    let rawPosts = responseData.content || responseData || []
    console.log('ğŸ“‹ æå–çš„åŠ¨æ€åˆ—è¡¨:', rawPosts)
    
    // å¤„ç†åŠ¨æ€æ•°æ®æ ¼å¼ï¼Œç¡®ä¿ä¸ç¤¾åŒºé¡µé¢ä¸€è‡´
    const processedPosts = rawPosts.map(post => {
      // å¤„ç†ä½œè€…å¤´åƒURL
      const authorAvatar = post.author?.avatarUrl || post.user?.avatar
      const fullAuthorAvatar = authorAvatar ? 
        (authorAvatar.startsWith('http') ? authorAvatar : `http://localhost:8080${authorAvatar}`) :
        '/imagines/members/avatar/member1.jpg'
      
      // å¤„ç†åŠ¨æ€å›¾ç‰‡URL
      const imageUrls = post.imageUrls || post.images || []
      const processedImages = Array.isArray(imageUrls) ? imageUrls.map(url => {
        // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å®Œæ•´URL
        if (url.startsWith('http')) {
          return url
        }
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸å¯¹è·¯å¾„
        if (url.startsWith('/')) {
          return `http://localhost:8080${url}`
        }
        // å…¶ä»–æƒ…å†µä¹ŸåŠ ä¸ŠåŸºç¡€URL
        return `http://localhost:8080/${url}`
      }) : []
      
      return {
        id: post.id,
        content: post.content,
        images: processedImages,
        user: {
          id: post.author?.id || post.user?.id,
          name: post.author?.name || post.author?.username || post.user?.name,
          avatar: fullAuthorAvatar
        },
        likes: post.likeCount || post.likes || 0,
        isLiked: post.isLiked || false,
        createdAt: new Date(post.createdAt),
        showComments: false,
        showFullText: false,
        comments: post.comments || [],
        commentCount: post.commentCount || (post.comments ? post.comments.length : 0)
      }
    })
    
    userPosts.value = processedPosts
    
    console.log('âœ… ç”¨æˆ·åŠ¨æ€å¤„ç†å®Œæˆ:', {
      åŸå§‹æ•°é‡: rawPosts.length,
      å¤„ç†åæ•°é‡: processedPosts.length,
      å¤„ç†åæ•°æ®: processedPosts
    })
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    if (userProfile.value.stats) {
      userProfile.value.stats.postsCount = processedPosts.length
    }
    
  } catch (error) {
    console.error('âŒ åŠ è½½ç”¨æˆ·åŠ¨æ€å¤±è´¥:', error)
    ElMessage.error('åŠ è½½åŠ¨æ€å¤±è´¥')
  }
}

// åŠ è½½ç”¨æˆ·ç›¸å†Œ
const loadUserPhotos = async () => {
  try {
    const userId = parseInt(route.params.id)
    console.log('ğŸ” åŠ è½½ç”¨æˆ·ç›¸å†Œï¼Œç”¨æˆ·ID:', userId)
    
    const photosData = await getUserPhotos(userId)
    console.log('ğŸ“¨ åŸå§‹ç›¸å†Œæ•°æ®:', photosData)
    
    // å¤„ç†ç›¸å†Œæ•°æ®æ ¼å¼
    let rawPhotos = photosData.content || photosData || []
    console.log('ğŸ“‹ æå–çš„ç›¸å†Œåˆ—è¡¨:', rawPhotos)
    
    // å¤„ç†ç…§ç‰‡URL
    const processedPhotos = rawPhotos.map(photo => {
      const photoUrl = photo.photoUrl || photo.url
      const fullPhotoUrl = photoUrl ? 
        (photoUrl.startsWith('http') ? photoUrl : `http://localhost:8080${photoUrl}`) :
        '/imagines/members/avatar/member1.jpg'
      
      return {
        ...photo,
        photoUrl: fullPhotoUrl,
        url: fullPhotoUrl
      }
    })
    
    userProfile.value.photos = processedPhotos
    
    console.log('âœ… ç”¨æˆ·ç›¸å†Œå¤„ç†å®Œæˆ:', {
      åŸå§‹æ•°é‡: rawPhotos.length,
      å¤„ç†åæ•°é‡: processedPhotos.length,
      å¤„ç†åæ•°æ®: processedPhotos
    })
    
  } catch (error) {
    console.error('âŒ åŠ è½½ç”¨æˆ·ç›¸å†Œå¤±è´¥:', error)
    ElMessage.error('åŠ è½½ç›¸å†Œå¤±è´¥')
  }
}

const handleMenuSelect = (key) => {
  console.log('å¯¼èˆªèœå•è¢«ç‚¹å‡»ï¼Œkey:', key)
  activeMenu.value = key
  if (key === '1') {
    router.push('/').catch(err => {
      console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
    })
  } else if (key === '2-1') {
    router.push('/team-history').catch(err => {
      console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
    })
  } else if (key === '2-2') {
    router.push('/team-member').catch(err => {
      console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
    })
  } else if (key === '3') {
    router.push('/routes').catch(err => {
      console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
    })
  } else if (key === '4') {
    // æ´»åŠ¨åŠ¨æ€é¡µé¢ - ä¸ªäººä¸»é¡µ
    // ä¸ªäººä¸»é¡µï¼Œä½†éœ€è¦è·å–å½“å‰ç”¨æˆ·ID
    if (currentUser.value?.id) {
      router.push(`/user/${currentUser.value.id}`).catch(err => {
        console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
      })
    } else {
      router.push('/community').catch(err => {
        console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
      })
    }
  } else if (key === '5') {
    router.push('/community').catch(err => {
      console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
    })
  } else if (key === '6') {
    router.push('/contact').catch(err => {
      console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
    })
  } else {
    console.warn('æœªçŸ¥çš„èœå•é¡¹:', key)
  }
}

const goBack = () => {
  console.log('è¿”å›ç¤¾åŒºæŒ‰é’®è¢«ç‚¹å‡»')
  router.push('/community').catch(err => {
    console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
  })
}

const goToCommunity = () => {
  console.log('å»ç¤¾åŒºæŒ‰é’®è¢«ç‚¹å‡»')
  router.push('/community').catch(err => {
    console.warn('è·¯ç”±è·³è½¬å¤±è´¥:', err)
  })
}

const goToPostDetail = (postId) => {
  router.push(`/community/post/${postId}`)
}

const viewRouteDetail = (routeId) => {
  router.push(`/routes/${routeId}`)
}

// ç¼–è¾‘ç”¨æˆ·ä¿¡æ¯
const editAvatar = () => {
  if (!isCurrentUser.value) {
    ElMessage.warning('åªèƒ½ç¼–è¾‘è‡ªå·±çš„å¤´åƒ')
    return
  }
  avatarInput.value?.click()
}

const handleAvatarUpload = async (event) => {
  const file = event.target.files[0]
  if (!file || !file.type.startsWith('image/')) {
    ElMessage.error('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶')
    return
  }
  
  // æ–‡ä»¶å¤§å°é™åˆ¶ (5MB)
  if (file.size > 5 * 1024 * 1024) {
    ElMessage.error('å¤´åƒæ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡5MB')
    return
  }
  
  // æ£€æŸ¥ç™»å½•çŠ¶æ€å’Œtoken
  const token = localStorage.getItem('woyun_token')
  const user = localStorage.getItem('woyun_user')
  
  console.log('ğŸ” ä¸Šä¼ å‰æ£€æŸ¥:', {
    hasToken: !!token,
    hasUser: !!user,
    tokenLength: token ? token.length : 0,
    tokenPreview: token ? `${token.substring(0, 30)}...` : 'NO_TOKEN',
    currentUser: currentUser.value
  })
  
  if (!token) {
    ElMessage.error('æœªç™»å½•æˆ–ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•')
    return
  }
  
  let loadingInstance = null
  
  try {
    isUploading.value = true
    loadingInstance = ElLoading.service({
      text: 'æ­£åœ¨ä¸Šä¼ å¤´åƒ...'
    })
    
    console.log('å¼€å§‹ä¸Šä¼ å¤´åƒ:', file.name, 'å¤§å°:', (file.size / 1024 / 1024).toFixed(2) + 'MB')
    
    const result = await uploadAvatar(file)
    
    console.log('å¤´åƒä¸Šä¼ æˆåŠŸ:', result)
    
    // æ„å»ºå®Œæ•´çš„å›¾ç‰‡URL
    const avatarUrl = result.avatarUrl
    let fullAvatarUrl = avatarUrl
    if (!avatarUrl.startsWith('http')) {
      if (avatarUrl.startsWith('/')) {
        fullAvatarUrl = `http://localhost:8080${avatarUrl}`
      } else {
        fullAvatarUrl = `http://localhost:8080/${avatarUrl}`
      }
    }
    
    console.log('æ›´æ–°å¤´åƒ URL:', fullAvatarUrl)
    
    // æ·»åŠ æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
    const timestampedUrl = `${fullAvatarUrl}?t=${Date.now()}`
    
    // æ›´æ–°æœ¬åœ°æ˜¾ç¤º
    userProfile.value.avatarUrl = timestampedUrl
    
    // æ›´æ–°å…¨å±€ç”¨æˆ·ä¿¡æ¯
    updateAuthUserInfo({ avatarUrl: timestampedUrl })
    
    ElMessage.success('å¤´åƒæ›´æ–°æˆåŠŸ')
    
  } catch (error) {
    console.error('å¤´åƒä¸Šä¼ å¤±è´¥:', error)
    ElMessage.error(error.message || 'å¤´åƒä¸Šä¼ å¤±è´¥')
  } finally {
    // ç¡®ä¿å…³é—­ Loading
    if (loadingInstance) {
      loadingInstance.close()
    }
    isUploading.value = false
    // æ¸…ç©ºè¾“å…¥æ¡†
    if (event.target) {
      event.target.value = ''
    }
  }
}

const startEditName = () => {
  if (!isCurrentUser.value) {
    ElMessage.warning('åªèƒ½ç¼–è¾‘è‡ªå·±çš„ä¿¡æ¯')
    return
  }
  editingName.value = true
  editNameValue.value = userProfile.value.name
  nextTick(() => {
    nameInput.value?.focus()
  })
}

const saveName = async () => {
  if (!editNameValue.value.trim()) {
    editingName.value = false
    return
  }
  
  try {
    const updatedUser = await updateUserInfo({
      name: editNameValue.value.trim()
    })
    
    userProfile.value.name = updatedUser.name
    updateAuthUserInfo({ name: updatedUser.name })
    
    ElMessage.success('ç”¨æˆ·åæ›´æ–°æˆåŠŸ')
  } catch (error) {
    console.error('æ›´æ–°ç”¨æˆ·åå¤±è´¥:', error)
    ElMessage.error(error.message || 'æ›´æ–°ç”¨æˆ·åå¤±è´¥')
  } finally {
    editingName.value = false
  }
}

const startEditTitle = () => {
  if (!isCurrentUser.value) {
    ElMessage.warning('åªèƒ½ç¼–è¾‘è‡ªå·±çš„ä¿¡æ¯')
    return
  }
  editingTitle.value = true
  editTitleValue.value = userProfile.value.title
  nextTick(() => {
    titleInput.value?.focus()
  })
}

const saveTitle = async () => {
  if (!editTitleValue.value.trim()) {
    editingTitle.value = false
    return
  }
  
  try {
    const updatedUser = await updateUserInfo({
      title: editTitleValue.value.trim()
    })
    
    userProfile.value.title = updatedUser.title
    
    ElMessage.success('é˜Ÿå†…titleæ›´æ–°æˆåŠŸ')
  } catch (error) {
    console.error('æ›´æ–°é˜Ÿå†…titleå¤±è´¥:', error)
    ElMessage.error(error.message || 'æ›´æ–°titleå¤±è´¥')
  } finally {
    editingTitle.value = false
  }
}

// ç›¸å†Œç®¡ç†
const addPhotos = () => {
  if (!isCurrentUser.value) {
    ElMessage.warning('åªèƒ½ç®¡ç†è‡ªå·±çš„ç›¸å†Œ')
    return
  }
  photosInput.value?.click()
}

const handlePhotosUpload = async (event) => {
  const files = Array.from(event.target.files)
  if (files.length === 0) return
  
  // éªŒè¯æ–‡ä»¶ç±»å‹å’Œå¤§å°
  const validFiles = files.filter(file => {
    if (!file.type.startsWith('image/')) {
      ElMessage.warning(`æ–‡ä»¶ ${file.name} ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶`)
      return false
    }
    if (file.size > 10 * 1024 * 1024) {
      ElMessage.warning(`æ–‡ä»¶ ${file.name} å¤§å°è¶…è¿‡10MB`)
      return false
    }
    return true
  })
  
  if (validFiles.length === 0) {
    event.target.value = ''
    return
  }
  
  let loadingInstance = null
  
  try {
    isUploading.value = true
    loadingInstance = ElLoading.service({
      text: `æ­£åœ¨ä¸Šä¼  ${validFiles.length} å¼ ç…§ç‰‡...`
    })
    
    console.log('å¼€å§‹ä¸Šä¼ ç…§ç‰‡:', validFiles.map(f => f.name))
    
    const uploadedPhotos = await uploadPhotos(validFiles)
    
    console.log('ç…§ç‰‡ä¸Šä¼ æˆåŠŸ:', uploadedPhotos)
    
    // å¤„ç†ä¸Šä¼ çš„ç…§ç‰‡URL
    const processedPhotos = uploadedPhotos.map(photo => {
      const photoUrl = photo.photoUrl || photo.url
      // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å®Œæ•´URL
      if (photoUrl.startsWith('http')) {
        return {
          ...photo,
          photoUrl: photoUrl,
          url: photoUrl
        }
      }
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸å¯¹è·¯å¾„
      if (photoUrl.startsWith('/')) {
        const fullPhotoUrl = `http://localhost:8080${photoUrl}`
        return {
          ...photo,
          photoUrl: fullPhotoUrl,
          url: fullPhotoUrl
        }
      }
      
      // å…¶ä»–æƒ…å†µä¹ŸåŠ ä¸ŠåŸºç¡€URL
      const fullPhotoUrl = `http://localhost:8080/${photoUrl}`
      return {
        ...photo,
        photoUrl: fullPhotoUrl,
        url: fullPhotoUrl
      }
    })
    
    console.log('å¤„ç†åçš„ç…§ç‰‡:', processedPhotos)
    
    // æ›´æ–°æœ¬åœ°æ˜¾ç¤º
    userProfile.value.photos.unshift(...processedPhotos)
    
    ElMessage.success(`æˆåŠŸä¸Šä¼  ${uploadedPhotos.length} å¼ ç…§ç‰‡`)
    
  } catch (error) {
    console.error('ç…§ç‰‡ä¸Šä¼ å¤±è´¥:', error)
    ElMessage.error(error.message || 'ç…§ç‰‡ä¸Šä¼ å¤±è´¥')
  } finally {
    // ç¡®ä¿å…³é—­ Loading
    if (loadingInstance) {
      loadingInstance.close()
    }
    isUploading.value = false
    event.target.value = ''
  }
}

const deletePhoto = async (index) => {
  if (!isCurrentUser.value) {
    ElMessage.warning('åªèƒ½åˆ é™¤è‡ªå·±çš„ç…§ç‰‡')
    return
  }
  
  try {
    await ElMessageBox.confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ ç…§ç‰‡å—ï¼Ÿ', 'æç¤º', {
      confirmButtonText: 'ç¡®å®š',
      cancelButtonText: 'å–æ¶ˆ',
      type: 'warning'
    })
    
    const photo = userProfile.value.photos[index]
    
    if (photo.id) {
      await deletePhotoAPI(photo.id)
    }
    
    userProfile.value.photos.splice(index, 1)
    ElMessage.success('ç…§ç‰‡åˆ é™¤æˆåŠŸ')
    
  } catch (error) {
    if (error !== 'cancel') {
      console.error('åˆ é™¤ç…§ç‰‡å¤±è´¥:', error)
      ElMessage.error(error.message || 'åˆ é™¤ç…§ç‰‡å¤±è´¥')
    }
  }
}

const viewPhoto = (photo, photos, index) => {
  const photoUrl = photo.photoUrl || photo.url
  currentViewImage.value = photoUrl
  viewerImages.value = photos.map(p => p.photoUrl || p.url)
  currentImageIndex.value = index
  showImageViewer.value = true
}

// åŠ¨æ€ç®¡ç†
const editPost = (postId) => {
  // TODO: å®ç°ç¼–è¾‘åŠ¨æ€åŠŸèƒ½
  console.log('ç¼–è¾‘åŠ¨æ€:', postId)
  ElMessage.warning('è¿™ä¸ªåŠŸèƒ½æˆ‘æ‡’å¾—åšäº†ï¼Œè‡ªå·±åˆ æ‰é‡å‘[æ„‰å¿«]')
}

const deletePost = (postId) => {
  if (confirm('çœŸå‘¢è¦åˆ æ‰å™¶ï¼Ÿ')) {
    const index = userPosts.value.findIndex(p => p.id === postId)
    if (index > -1) {
      userPosts.value.splice(index, 1)
      userProfile.value.stats.postsCount--
    }
    // TODO: è°ƒç”¨åç«¯APIåˆ é™¤åŠ¨æ€
    console.log('åˆ é™¤åŠ¨æ€:', postId)
  }
}

const toggleLike = (postId) => {
  const post = userPosts.value.find(p => p.id === postId)
  if (post) {
    if (post.isLiked) {
      post.likes--
      post.isLiked = false
    } else {
      post.likes++
      post.isLiked = true
    }
  }
  // TODO: è°ƒç”¨åç«¯APIæ›´æ–°ç‚¹èµçŠ¶æ€
}

const formatTime = (date) => {
  const now = new Date()
  const diff = now - date
  const minutes = Math.floor(diff / (1000 * 60))
  const hours = Math.floor(diff / (1000 * 60 * 60))
  const days = Math.floor(diff / (1000 * 60 * 60 * 24))
  
  if (minutes < 60) {
    return `${minutes}åˆ†é’Ÿå‰`
  } else if (hours < 24) {
    return `${hours}å°æ—¶å‰`
  } else {
    return `${days}å¤©å‰`
  }
}

const getTruncatedText = (text) => {
  return text.length > 100 ? text.substring(0, 100) : text
}

const toggleFullText = (postId) => {
  const post = userPosts.value.find(p => p.id === postId)
  if (post) {
    post.showFullText = !post.showFullText
  }
}

const getDifficultyText = (difficulty) => {
  const map = {
    easy: 'ç®€å•',
    medium: 'ä¸­ç­‰',
    hard: 'å›°éš¾'
  }
  return map[difficulty] || difficulty
}

const getTypeText = (type) => {
  const map = {
    mountain: 'å±±åœ°',
    road: 'å…¬è·¯',
    city: 'åŸå¸‚',
    scenic: 'é£æ™¯'
  }
  return map[type] || type
}

// æ»šåŠ¨åŠ¨ç”»è§‚å¯Ÿå™¨
const observeElements = () => {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add('fade-in-active')
        }
      })
    },
    {
      threshold: 0.1,
      rootMargin: '0px 0px -50px 0px'
    }
  )

  // è§‚å¯Ÿå„ä¸ªåŒºåŸŸ
  const elementsToObserve = [
    userInfoRef.value,
    galleryRef.value,
    postsRef.value,
    routesRef.value  // æ·»åŠ è·¯çº¿åŒºåŸŸ
  ]
  
  elementsToObserve.forEach((el) => {
    if (el) {
      observer.observe(el)
    }
  })

  // è§‚å¯ŸåŠ¨æ€å¡ç‰‡
  Object.values(postRefs).forEach((el) => {
    if (el) {
      observer.observe(el)
    }
  })
}

// åˆ é™¤è·¯çº¿
const removeRoute = (routeId) => {
  deleteRouteConfirm(routeId)
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  // èƒŒæ™¯æ¸æ˜¾åŠ¨ç”»
  if (backgroundRef.value) {
    backgroundRef.value.classList.add('background-fade-in')
  }
  
  // å»¶è¿Ÿåˆå§‹åŒ–åŠ¨ç”»è§‚å¯Ÿå™¨
  setTimeout(() => {
    observeElements()
  }, 100)
  
  // åŠ è½½ç”¨æˆ·æ•°æ®
  await loadUserProfile()
  // å¹¶è¡ŒåŠ è½½ç”¨æˆ·ç›¸å†Œã€åŠ¨æ€å’Œè·¯çº¿æ•°æ®ï¼Œä½†åˆ†åˆ«å¤„ç†é”™è¯¯ï¼Œé¿å…ä¸€ä¸ªå¤±è´¥å½±å“å…¶ä»–
  await Promise.all([
    loadUserPhotos().catch(err => {
      console.error('åŠ è½½ç”¨æˆ·ç›¸å†Œå¤±è´¥:', err)
    }),
    loadUserPosts().catch(err => {
      console.error('åŠ è½½ç”¨æˆ·åŠ¨æ€å¤±è´¥:', err)
    }),
    loadUserRoutes().catch(err => {
      console.error('åŠ è½½ç”¨æˆ·è·¯çº¿å¤±è´¥:', err)
    })
  ])
  
  console.log('ä¸ªäººä¸»é¡µåŠ è½½å®Œæˆ')
})
</script>